# SPDX-License-Identifier: AGPL-3.0-only
# SPDX-FileCopyrightText: 2024 Univention GmbH
---
global:
  # -- Indicates to all subcharts that they are being used as part of a Nubus deployment.
  nubusDeployment: true
  # -- Master password from which other passwords are derived.
  nubusMasterPassword: ""
  ldap:
    baseDn: ""
    domainName: ""
    auth:
      cnAdmin:
        password: ~

  domain: ""
  subDomains:
    portal: portal
    keycloak: id
  ingressClass: ""
  certManagerIssuer: ""
  postgresql:
    connection:
      host: ""
      port: ""
  objectStorage:
    bucket: "nubus"
    connection:
      host: ""
      port: ""
      protocol: ""
      endpoint: ""
  memcached:
    connection:
      host: ""
    auth:
      username: ""
  keycloak:
    realm: "nubus"
  # -- Allow plain UMC login (otherwise only SAML login is possible)
  # Be aware this will expose the UMC login page to the public, which can
  # circumvent 2FA and other security measures placed in the IdP.
  enablePlainUmcLogin: false

  configMapUcr: "{{ .Release.Name }}-stack-data-ums-ucr"

  configUcr:
    umc:
      module:
        debug:
          level: 2 # default loglevel (subchart): 5
      server:
        debug:
          level: 2 # default loglevel (subchart): 5
    apache2:
      loglevel: "info" # default loglevel (subchart): warn

  # -- Extensions to load. Add entries to load additional extensions into Nubus.
  extensions: []

  # -- Allows to configure the system extensions to load. This is intended for
  # internal usage, prefer to use `global.extensions` for user configured
  # extensions.
  systemExtensions:
    - name: "portal"
      image:
        registry: "artifacts.software-univention.de"
        repository: "nubus/images/portal-extension"
        imagePullPolicy: "IfNotPresent"
        tag: "0.43.0@sha256:140309be03b1021693bd9781453e36c14fab6d0ad21448be8bf251342c86695b"

  # TODO: Remove when done
  # Credentials that are primarily or exclusively used by the umbrella chart can be overridden in some cases. This is the place to do it.
  credentialOverride:
    defaultUsers:
      defaultAdministratorPassword: ""
      defaultAdminPassword: ""
      defaultUserPassword: ""
    selfserviceConsumer:
      natsPassword: ""
      provisioningApi:
        password: ""

# -- Additional custom annotations to add to all objects deployed directly by the umbrella chart.
additionalAnnotations: {}

# -- Additional custom labels to add to all objects deployed directly by the umbrella chart.
additionalLabels: {}

# -- SAML certificates generation
certificates:
  # -- Enable SAML self-signed certificate generation. This required cert-manager.io
  enabled: true

# -- Define and create Kubernetes Ingress.
# Ref.: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  # -- Enable creation of Ingress.
  enabled: true

  # -- Define the Fully Qualified Domain Name (FQDN) where application should be reachable.
  host: ""

  # -- Request certificates via cert-manager.io annotation
  certManager:
    # -- Enable cert-manager.io annotaion.
    enabled: true

    # Issuer reference.
    issuerRef:
      # -- Name of cert-manager.io Issuer resource.
      name: ""
      # -- Type of Issuer, f.e. "Issuer" or "ClusterIssuer".
      kind: "ClusterIssuer"

  # -- The Ingress controller class name.
  ingressClassName: ""
  # -- Define custom ingress annotations.
  # annotations:
  #   nginx.ingress.kubernetes.io/rewrite-target: /
  annotations:
    nginx.ingress.kubernetes.io/proxy-body-size: "128k"
    nginx.ingress.kubernetes.io/proxy-buffer-size: "64k"
    nginx.ingress.kubernetes.io/proxy-buffers-number: "4"
    nginx.ingress.kubernetes.io/proxy-busy-buffers-size: "128k"
    nginx.ingress.kubernetes.io/proxy-http-version: "1.1"
    nginx.ingress.kubernetes.io/proxy-set-headers: |
      Host $http_host;
      X-Forwarded-For $proxy_add_x_forwarded_for;
      X-Forwarded-Host $http_x_forwarded_host;
      X-Forwarded-Port $http_x_forwarded_port;
      X-Forwarded-Proto $http_x_forwarded_proto;
    nginx.ingress.kubernetes.io/use-regex: "true"

  # -- Secure an Ingress by specifying a Secret that contains a TLS private key and certificate.
  #
  # Ref.: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
  tls:
    # -- Enable TLS/SSL/HTTPS for Ingress.
    enabled: true

    # -- The name of the kubernetes secret which contains a TLS private key and certificate.
    # Hint: This secret is not created by this chart and must be provided.
    secretName: ""

nubusDevelopment:
  resources: &nubusDevelopmentResources
    limits:
      cpu: 288
      memory: "1Gi"
    requests:
      cpu: "10m"
      memory: "16Mi"
  terminationGracePeriodSeconds: &nubusTerminationGracePeriodSeconds 5

postgresql:
  enabled: true
  resources: *nubusDevelopmentResources
  auth:
    existingSecret: "{{ .Release.Name }}-postgresql-credentials"
    username: "nubus"
    secretKeys:
      adminPasswordKey: "admin_password"
      userPasswordKey: "user_password"
      replicationPasswordKey: "replication_password"
  tls:
    enabled: false
    existingSecret: "{{ .Release.Name }}-postgresql-tls"
    certFilename: "tls.crt"
    certKeyFilename: "tls.key"
    certCaFilename: "ca.crt"
  provisioning:
    enabled: true
    ttlSecondsAfterFinished: 30
    image:
      registry: "docker.io"
      repository: "bitnami/postgresql"
      tag: "15.4.0-debian-11-r45"
    containerSecurityContext:
      enabled: true
      seLinuxOptions: {}
      runAsUser: 1001
      runAsGroup: 1001
      runAsNonRoot: true
      privileged: false
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
      seccompProfile:
        type: "RuntimeDefault"
  primary:
    resources: *nubusDevelopmentResources
    terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds

minio:
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  enabled: true
  resources: *nubusDevelopmentResources
  networkPolicy:
    enabled: false
    resources: *nubusDevelopmentResources
  auth:
    rootUser: admin
    existingSecret: "{{ .Release.Name }}-minio-credentials"
  tls:
    enabled: false
    resources: *nubusDevelopmentResources
    existingSecret: "{{ .Release.Name }}-minio-tls"
  defaultBuckets: "nubus"

  provisioning:
    enabled: true
    resources: *nubusDevelopmentResources
    cleanupAfterFinished:
      enabled: true
      seconds: 900
      resources: *nubusDevelopmentResources
    extraCommands:
      - "mc anonymous set download provisioning/nubus/portal-assets"
    buckets:
      - name: "nubus"
        versioning: false
        withLock: false
    policies:
      - name: "nubus-bucket-policy"
        statements:
          - resources:
              - "arn:aws:s3:::nubus"
            effect: "Allow"
            actions:
              - "s3:*"
          - resources:
              - "arn:aws:s3:::nubus/*"
            effect: "Allow"
            actions:
              - "s3:*"
    usersExistingSecrets:
      - nubus-minio-provisioning

keycloak:
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  enabled: true
  resources: *nubusDevelopmentResources
  replicaCount: 1
  postgresql:
    connection:
      host: ""
      port: ""
    auth:
      username: keycloak_user
      database: keycloak
      credentialSecret:
        key: password
  config:
    logLevel: "INFO" # default loglevel (subchart): INFO
  ingress:
    enabled: true

nubusGuardian: &nubusGuardian
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "guardian"
  enabled: false
  ingress:
    host: "{{ .Values.global.subDomains.portal }}.{{ .Values.global.domain }}"
  resources: *nubusDevelopmentResources
  postgresql:
    bundled: false
    connection:
      host: ""
      port: ""
    auth:
      database: guardian
      username: guardian
      credentialSecret:
        key: password
  provisioning:
    enabled: true
    config:
      keycloak:
        username: "kcadmin"
        credentialSecret:
          key: adminPassword
      managementApi:
        credentialSecret:
          key: managementApiClientSecret
nubusLdapNotifier: &nubusLdapNotifier
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "ldap-notifier"
  enabled: true
  resources: *nubusDevelopmentResources
nubusLdapServer: &nubusLdapServer
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "ldap-server"
  enabled: true
  highAvailabilityMode: false
  replicaCountPrimary: 1
  replicaCountSecondary: 1
  replicaCountProxy: 1
  resourcesPrimary: *nubusDevelopmentResources
  resourcesSecondary: *nubusDevelopmentResources
  resourcesProxy: *nubusDevelopmentResources
nubusNotificationsApi: &nubusNotificationsApi
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "notifications-api"
  enabled: true
  resources: *nubusDevelopmentResources
  ingress:
    host: "{{ .Values.global.subDomains.portal }}.{{ .Values.global.domain }}"
  postgresql:
    bundled: false
    connection:
      host: ""
      port: ""
    auth:
      username: notificationsapi_user
      database: notificationsapi
      credentialSecret:
        key: password
  notificationsApi:
    logLevel: "INFO" # default loglevel (subchart): WARNING
nubusPortalFrontend: &nubusPortalFrontend
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "portal-frontend"
  enabled: true
  resources: *nubusDevelopmentResources
  ingress:
    host: "{{ .Values.global.subDomains.portal }}.{{ .Values.global.domain }}"
  portalFrontend:
    logLevel: "INFO" # default loglevel (subchart): WARNING

nubusPortalConsumer: &nubusPortalConsumer
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "portal-consumer"
  enabled: true
  resources: *nubusDevelopmentResources
  objectStorage:
    auth:
      accessKey: null
      secretKey: null
  # TODO: Not yet supported
  # udm:
  #   auth:
  #     password: null
  portalConsumer:
    ldapHost: "{{ .Release.Name }}-ldap-server-primary"
    objectStorageBucket: "nubus"
  provisioningApi:
    auth:
      username: "portal-consumer"
      password: null
nubusPortalServer: &nubusPortalServer
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "portal-server"
  enabled: true
  ingress:
    host: "{{ .Values.global.subDomains.portal }}.{{ .Values.global.domain }}"
  objectStorage:
    auth:
      accessKey: null
      secretKey: null
  resources: *nubusDevelopmentResources
  portalServer:
    objectStorageBucket: "nubus"
    logLevel: "INFO" # default loglevel (subchart): WARNING

nubusProvisioning: &nubusProvisioning
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "provisioning"

  enabled: true
  resources:
    dispatcher: *nubusDevelopmentResources
    prefill: *nubusDevelopmentResources
    api: *nubusDevelopmentResources
  nats:
    config:
      cluster:
        # TODO: Set back to the default of 3 after nats clustering is solved.
        replicas: 1
    auth:
      adminPassword: null
    global:
      imageRegistry: "docker.io"
    resources: *nubusDevelopmentResources
    reloader:
      resources: *nubusDevelopmentResources
    natsBox:
      resources: *nubusDevelopmentResources
  api:
    auth:
      adminPassword: null
      prefillPassword: null
      udmTransformerPassword: null
    nats:
      connection:
        host: ""
        port: ""
        username: events_and_consumer_api
        password:
          secretKeyRef:
            key: password
      auth:
        password: null
    config:
      LOG_LEVEL: "INFO" # default loglevel (subchart): INFO
  dispatcher:
    nats:
      connection:
        host: ""
        port: ""
        username: dispatcher
        password:
          secretKeyRef:
            key: password
      auth:
        password: null
    config:
      LOG_LEVEL: "INFO" # default loglevel (subchart): INFO
  prefill:
    nats:
      connection:
        host: ""
        port: ""
        username: prefill
        password:
          secretKeyRef:
            key: password
      auth:
        password: null
    config:
      LOG_LEVEL: "INFO" # default loglevel (subchart): INFO
  udmTransformer:
    ldap:
      connection:
        host: "{{ .Release.Name }}-ldap-server-primary"
    nats:
      auth:
        password: null
    config:
      LOG_LEVEL: "INFO" # default loglevel (subchart): INFO

nubusUdmListener: &nubusUdmListener
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "provisioning-listener"
  enabled: true
  resources: *nubusDevelopmentResources
  ldap:
    connection:
      host: ""
      port: ""
    auth:
      bindDn: cn=admin,dc=example,dc=org
      # TODO: Needs adjustment together with the sub-chart
      credentialSecret:
        key: password
  nats:
    auth:
      password: null
  config:
    ldapHost: "{{ .Release.Name }}-ldap-server-primary"
    debugLevel: "2" # default loglevel (subchart): 2

nubusSelfServiceConsumer: &nubusSelfServiceConsumer
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "selfservice-listener"
  enabled: true
  resources: *nubusDevelopmentResources
  provisioningApi:
    auth:
      username: "selfservice"
      existingSecret:
        name: '{{ include "nubus.provisioning.selfserviceConsumer.auth.existingSecret.name" . }}'
        keyMapping:
          password: "PROVISIONING_API_PASSWORD"
nubusUdmRestApi: &nubusUdmRestApi
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "udm-rest-api"
  enabled: true
  ingress:
    host: "{{ .Values.global.subDomains.portal }}.{{ .Values.global.domain }}"
  resources: *nubusDevelopmentResources
  ldap:
    connection:
      host: ""
      port: ""
    auth:
      bindDn: cn=admin,dc=example,dc=org
      # TODO: Needs adjustment together with the component chart
      credentialSecret:
        key: password
nubusUmcGateway: &nubusUmcGateway
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "umc-gateway"
  enabled: true
  ingress:
    host: "{{ .Values.global.subDomains.portal }}.{{ .Values.global.domain }}"
  resources: *nubusDevelopmentResources
nubusUmcServer: &nubusUmcServer
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "umc-server"
  replicaCount: 1
  enabled: true
  ingress:
    host: "{{ .Values.global.subDomains.portal }}.{{ .Values.global.domain }}"
  resources: *nubusDevelopmentResources
  postgresql:
    connection:
      host: ""
      port: ""
    auth:
      username: selfservice
      database: selfservice
      credentialSecret:
        key: password
  global:
    imageRegistry: "docker.io"
  image:
    registry: "artifacts.software-univention.de"
  memcached:
    nameOverride: "umc-server-memcached"
    containerSecurityContext:
      readOnlyRootFilesystem: false
    auth:
      username: selfservice
      existingPasswordSecret: '{{ printf "%s-umc-server-memcached-credentials" .Release.Name }}'
      credentialSecret:
        key: "memcached-password"
        name: ""
    connection:
      host: ""
      port: ""
      username: umcserver
  umcServer:
    certPemFile: "/var/secrets/ssl/tls.crt"
    privateKeyFile: "/var/secrets/ssl/tls.key"
  proxy:
    logLevel: "INFO" # default loglevel (subchart): INFO
  extraVolumes:
    - name: "certificates"
      secret:
        secretName: "{{ .Release.Name }}-saml-tls"
  extraVolumeMounts:
    - name: "certificates"
      mountPath: "/var/secrets/ssl"
nubusKeycloakBootstrap: &nubusKeycloakBootstrap
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "keycloak-bootstrap"
  enabled: true
  resources: *nubusDevelopmentResources
nubusKeycloakExtensions: &nubusKeycloakExtensions
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "keycloak-extensions"
  enabled: false
  resources: *nubusDevelopmentResources
  smtp:
    connection:
      host: ""
    auth:
      username: "keycloak-extensions"
      credentialSecret:
        key: password
  keycloak:
    connection:
      host: ""
    auth:
      username: "kcadmin"
      credentialSecret:
        key: password
  postgresql:
    connection:
      host: ""
      port: ""
    auth:
      database: keycloak_extensions
      username: keycloak_extensions
      credentialSecret:
        key: password
  handler:
    appConfig:
      logLevel: "INFO"  # default loglevel (subchart): DEBUG
  proxy:
    appConfig:
      logLevel: "info" # default loglevel (subchart): debug

nubusStackDataUms:
  terminationGracePeriodSeconds: *nubusTerminationGracePeriodSeconds
  nameOverride: "stack-data-ums"
  enabled: true
  resources: *nubusDevelopmentResources
  nubusNotificationsApi: *nubusNotificationsApi
  nubusUmcServer: *nubusUmcServer
  nubusKeycloakExtensions: *nubusKeycloakExtensions
  nubusKeycloakBootstrap: *nubusKeycloakBootstrap
  nubusPortalConsumer: *nubusPortalConsumer
  nubusPortalServer: *nubusPortalServer
  nubusProvisioning: *nubusProvisioning
  nubusUdmListener: *nubusUdmListener
  nubusSelfServiceConsumer: *nubusSelfServiceConsumer
  nubusUdmRestApi: *nubusUdmRestApi
  stackDataContext:
    ldapMasterHost: '{{ include "nubusTemplates.connections.ldap.primary.host" . }}'
    ldapHost: '{{ include "nubusTemplates.connections.ldap.primary.host" . }}'

  templateContext:
    ldapSearchUsers: [ ]
    ldapSystemUsers:
      - username: "readonly"
        lastname: "LDAP-system-User"
        password: '{{ include "nubusTemplates.credentials.ldap.users.readonly.password" . }}'
    readonlyUserPassword: '{{ include "nubusTemplates.credentials.ldap.users.readonly.password" . }}'


# Allows for creation of additional secrets, for example containing credentials for third party services.
extraSecrets: []
